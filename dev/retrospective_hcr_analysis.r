rm(list=ls())

library(tidyverse)
library(ggdist)
library(ggh4x)
library(reshape2)
library(SpatialSablefishAssessment)
library(tictoc)
library(doParallel)

# library(afscOM) # may work but not certain

# Change to wherever your local copy of afscOM is
library(devtools)
afscOM_dir <- "~/Desktop/Projects/afscOM"
sablefishMSE_dir <- here::here()

devtools::load_all(afscOM_dir)
devtools::load_all(sablefishMSE_dir)

source("R/reference_points.R")
source("R/harvest_control_rules.R")
source("R/simulate_TAC.R")
source("R/age_structure_stats.R")
source("R/data_utils.R")
source("R/data_processing.R")
source("R/run_mse.R")
source("R/run_mse_multiple.R")
source("R/run_mse_parallel.R")
source("R/format_em_data.R")
source("R/fit_TMB_model.R")
source("R/recruitment_utils.R")
source("R/setup_mse_options.R")
source("R/plotting.R")

special_recruitment <- function(hist_recruits, nyears, seed){
    rec <- rep(NA, nyears)
    rec[1:length(hist_recruits)] <- hist_recruits
    rec[(length(hist_recruits)+1):nyears] <- rlnorm(nyears-length(rec[!is.na(rec)]), meanlog=log(15), sdlog=0.20)
    return(rec)
}

#' 1. Set up the OM by defining demographic parameters
#' model options (such as options governing the observation
#' processes), and OM initial conditons
nyears <- 70

sable_om <- readRDS("data/sablefish_om_big.RDS") # Read this saved OM from a file

# Define recruitment to occur via historical resampling
assessment <- dget("data/sablefish_assessment_2023.rdat")
hist_recruits <- assessment$natage.female[,1]*2

om7 <- sable_om
om7$recruitment$func <- special_recruitment
om7$recruitment$pars <- list(
    hist_recruits = hist_recruits[54:64],
    nyears = nyears - length(hist_recruits[1:54]) + 1
)

om_list <- listN(om7)

# sable_om$recruitment$func <- beverton_holt
# sable_om$recruitment$pars <- list(
#     h = 0.7,
#     R0 = 20,
#     S0 = 282,
#     sigR = 1.04
# )

# sable_om$recruitment$func <- resample_regime_recruits
# sable_om$recruitment$pars <- list(
#     regime1_recruits = hist_recruits[-c(20:24, 40:44, 57:63)],
#     regime2_recruits = hist_recruits[c(20:24, 40:44, 57:63)],
#     nyears = nyears - length(hist_recruits) + 1,
#     regime_length = c(20, 5),
#     starting_regime = 0
# )

# sable_om$recruitment$func <- resample_recruits
# sable_om$recruitment$pars <- list(
#     hist_recruits = hist_recruits,
#     nyears = nyears - length(hist_recruits) + 1
# )

# sable_om$recruitment$func <- regime_recruits
# sable_om$recruitment$pars <- list(
#     mus = c(25, 10),
#     cvs = c(0.40, 0.40),
#     nyears = nyears - length(hist_recruits) + 1,
#     regime_length = c(20, 20),
#     starting_regime = 0
# )

#' 2. Define a harvest control rule (HCR) function to use to project TAC
#' in future years. Such function must take accept the following parameters:
#' ref_pts: a list of reference points as generated by `calculate_ref_points`,
#'          (Fref and Bref)
#' naa: a vector of numbers-at-age for a given year (should be [1, nages, nsexes, nregions])
#' dem_params: a list of demographic parameter values subsetted to a single year
#' 
#' HCR functions can accept as many additional parameters as required.
#' 
#' Below is an example implementation of the NPFMCs Tier 3a HCR     
tier3 <- function(ref_pts, naa, dem_params, cutoff_age=1){
    nages <- afscOM::get_model_dimensions(dem_params$sel)$nages
    a <- cutoff_age-1
    ssb <- apply(naa[,a:nages,1,]*dem_params$waa[,a:nages,1,,drop=FALSE]*dem_params$mat[,a:nages,1,,drop=FALSE], 1, sum)
    return(
        npfmc_tier3_F(ssb, ref_pts$Bref, ref_pts$Fref)
    )
}

pfmc4010 <- function(ref_pts, naa, dem_params, pstar=0.45, OFLsigma=0.32){

    ssb <- apply(naa[,,1,]*dem_params$waa[,,1,,drop=FALSE]*dem_params$mat[,,1,,drop=FALSE], 1, sum)
    dep <- ssb/ref_pts$B0

    # From Maia
    OFL <- ref_pts$Fref*ssb
    ABC <- OFL*exp(qnorm(pstar, 0, OFLsigma))
    if(dep < 0.1){TAC <- 0}
    if(dep > 0.40) {TAC <- ABC}
    if(dep <= 0.40 & dep >= 0.1){
    #   TAC <- ref_pts$Fref*ssb*((ssb-0.1*ref_pts$B0)/(0.4*ref_pts$B0 -0.1*ref_pts$B0))
        TAC <- ABC*(dep-0.1)/(0.4-0.1)
    }

    return(TAC)
}

tier3_selected <- function(ref_pts, naa, dem_params){
    # Assume a 70-30 split across fleets
    joint <- calculate_joint_selret(dem_params$sel, dem_params$ret, prop_fs = c(0.70, 0.30))
    selected_bio <- sum(naa*dem_params$waa*joint$sel)
    return(
        npfmc_tier3_F(selected_bio, ref_pts$Bref, ref_pts$Fref)
    )
}

# Going to start an MSE Options list distinct from everything else
mse_options <- setup_mse_options() # get default values
mse_options$management$tac_land_reduction = list(
    func = stairstep_attainment,
    pars = list(
        breakpoints = c(20, 30),
        levels = c(0.874, 0.786, 0.647),
        phase_ins = 2
    )
)

mp1 <- mse_options
mp1$hcr <- list(
    func = tier3,
    extra_pars = NA,
    extra_options = list(
        max_stability = NA,
        harvest_cap = NA
    ),
    ref_points = list(
        spr_target = 0.40
    ),
    units = "F"
)

mp2 <- mse_options
mp2$hcr <- list(
    func = tier3,
    extra_pars = NA,
    extra_options = list(
        max_stability = 0.10,
        harvest_cap = NA
    ),
    ref_points = list(
        spr_target = 0.40
    ),
    units = "F"
)

mp3 <- mse_options
mp3$hcr <- list(
    func = tier3,
    extra_pars = NA,
    extra_options = list(
        max_stability = 0.15,
        harvest_cap = NA
    ),
    ref_points = list(
        spr_target = 0.40
    ),
    units = "F"
)

mp4 <- mse_options
mp4$hcr <- list(
    func = tier3,
    extra_pars = NA,
    extra_options = list(
        max_stability = 0.25,
        harvest_cap = NA
    ),
    ref_points = list(
        spr_target = 0.40
    ),
    units = "F"
)

mp5 <- mse_options
mp5$ref_points$spr_target <- 0.50
mp5$hcr <- list(
    func = tier3,
    extra_pars = NA,
    extra_options = list(
        max_stability = NA,
        harvest_cap = NA
    ),
    ref_points = list(
        spr_target = 0.40
    ),
    units = "F"
)

mp6 <- mse_options
mp6$hcr <- list(
    func = tier3,
    extra_pars = list(cutoff_age = 7),
    extra_options = list(
        max_stability = NA,
        harvest_cap = NA
    ),
    ref_points = list(
        spr_target = 0.40
    ),
    units = "F"
)

mp7 <- mse_options
mp7$hcr <- list(
    func = tier3,
    extra_pars = list(cutoff_age = 14),
    extra_options = list(
        max_stability = NA,
        harvest_cap = NA
    ),
    ref_points = list(
        spr_target = 0.40
    ),
    units = "F"
)

mp8 <- mse_options
mp8$hcr <- list(
    func = pfmc4010,
    extra_pars = NA,
    extra_options = list(
        max_stability = NA,
        harvest_cap = NA
    ),
    ref_points = list(
        spr_target = 0.45
    ),
    units = "TAC"
)

mp9 <- mse_options
mp9$hcr <- list(
    func = tier3,
    extra_pars = NA,
    extra_options = list(
        max_stability = NA,
        harvest_cap = 15
    ),
    ref_points = list(
        spr_target = 0.40
    ),
    units = "F"
)

mp10 <- mse_options
mp10$hcr <- list(
    func = tier3,
    extra_pars = NA,
    extra_options = list(
        max_stability = NA,
        harvest_cap = 20
    ),
    ref_points = list(
        spr_target = 0.40
    ),
    units = "F"
)

mp11 <- mse_options
mp11$hcr <- list(
    func = tier3,
    extra_pars = NA,
    extra_options = list(
        max_stability = NA,
        harvest_cap = 25
    ),
    ref_points = list(
        spr_target = 0.40
    ),
    units = "F"
)

hcr_list <- listN(mp1, mp2, mp3, mp4, mp5, mp6, mp7, mp8, mp9, mp10, mp11)

#' 3. Run the closed-loop MSE simulation
#' A single MSE simulation can be run using the `run_mse(...)`
#' function, while multiple MSE simulations can be run (serially)
#' using the `run_mse_multiple(...)` function.
#' 
#' It is recommended to always use `run_mse_multiple(...)` even
#' when only a single MSE simulation is required.
set.seed(1007)
nsims <- 18
seed_list <- sample(1:(1000*nsims), nsims)  # Draw 10 random seeds

# mp5_modelrun <- run_mse_parallel(nsims, seed_list, om1, mp5, mse_options, nyears)
model_runs <- run_mse_multiple(
    om_list, 
    hcr_list, 
    seed_list,
    nyears=nyears, 
    mse_options=list(mse_options),
    spinup_years = 54,
    run_estimation=TRUE
)

hcr_names <- c("F40", "F40 +/-10%", "F40 +/-15%", "F40 +/-25%", "F50", "F40 >7yo", "F40 >14yo", "PFMC 40-10", "F40 15k Cap", "F40 20k Cap", "F40 25k Cap")

extra_columns <- data.frame(
    om = "om1",
    hcr = hcr_names
)

mse_runs <- listN(om_list, hcr_list, seed_list, model_runs, extra_columns)
saveRDS(mse_runs, "data/mse_retrosective_2014.RDS")

interval_widths=c(0.50, 0.80)

mse_runs <- readRDS("data/mse_retrosective_2014.RDS")
model_runs <- mse_runs$model_runs
extra_columns <- mse_runs$extra_columns

plot_mse_summary(model_runs, extra_columns, sable_om$dem_params, common_trajectory = 54)+
    geom_vline(xintercept=64, linetype="longdash")+
    facet_wrap(~L1, scales="free_y")+
    ggh4x::facetted_pos_scales(
        y = list(
            scale_y_continuous(limits=c(0, 60)),
            scale_y_continuous(limits=c(0, 60)),
            scale_y_continuous(limits=c(0, 0.20)),
            scale_y_continuous(limits=c(0, 350))
        )
    )+
    custom_theme
ggsave(file.path("~/Desktop/sablefish_plots", "retrospective_hcrs.png"), height=12, width=8, units="in")
 
ssb_data <- get_ssb_biomass(model_runs, extra_columns, sable_om$dem_params)
plot_ssb(ssb_data, v1="hcr", v2="om", common_trajectory=40)+labs(x="Year", y="SSB")+scale_y_continuous(limits=c(0, max(ssb_data$spbio)))

catch_data <- get_landed_catch(model_runs, extra_columns)
plot_landed_catch(catch_data, v1="hcr", common_trajectory = 40)

abctac <- get_management_quantities(model_runs, extra_columns, spinup_years = 54)
plot_abc_tac(abctac, v1="hcr", common_trajectory = 54)+
    facet_wrap(~L1, scales="free_y")+
    ggh4x::facetted_pos_scales(
        y=list(
            scale_y_continuous(limits=c(0, 100)),
            scale_y_continuous(limits=c(0.5, 1.5)),
            scale_y_continuous(limits=c(0, 100)),
            scale_y_continuous(limits=c(0, 100))
        )
    )+custom_theme
ggsave(filename=file.path("~/Desktop/sablefish_plots/", "retrospetive_hcr_trajectories.png"), width=5*1.7, height=8*1.7, units="in")

perf_summ <- performance_metric_summary(model_runs, extra_columns, sable_om$dem_params, interval_widths=c(0.50, 0.80))
perf_data <- perf_summ$perf_data

om_summary <- perf_data %>% filter(.width == 0.50) %>% 
    group_by(om, name) %>% 
    summarise(value = mean(median))

ggplot(perf_data)+
    geom_pointinterval(aes(x=median, xmin=lower, xmax=upper, y=hcr, color=hcr, shape=om), point_size=3, position="dodge")+
    geom_vline(data=om_summary, aes(xintercept = value), color="black")+
    scale_shape_discrete()+
    facet_wrap(~name, scales="free_x")+
    ggh4x::facetted_pos_scales(
        x = list(
            scale_x_continuous(limits=c(0, 300), breaks=seq(0, 300, 50), labels = seq(0, 300, 50)),
            scale_x_continuous(limits=c(0, 400), breaks=seq(0, 600, 200), labels=seq(0, 600, 200)),
            scale_x_continuous(limits=c(0, 0.07), breaks=seq(0, 0.06, 0.02), labels=seq(0, 0.06, 0.02)),
            scale_x_continuous(limits=c(0, 1), breaks=seq(0, 1, 0.25), labels=seq(0, 100, 25)),
            scale_x_continuous(limits=c(0, 0.25), breaks=seq(0, 0.25, 0.05), labels=seq(0, 25, 5)),
            scale_x_continuous(limits=c(0, 20), breaks=seq(0, 40, 10), labels=seq(0, 40, 10)),
            scale_x_continuous(limits=c(250, 1000))
        )
    )+
    # facet_wrap(vars(name), scales="free_x")+
    labs(y="", x="", shape="OM", color="HCR")+
    coord_cartesian(expand=0)+
    guides(shape=guide_legend(nrow=3), color=guide_legend(nrow=4))+
    theme_bw()+
    theme(
        plot.margin = margin(0.25, 1, 0.25, 0.25, "cm"),
        panel.spacing.x = unit(0.5, "cm"),
        plot.title = element_text(size=18),
        legend.spacing.x = unit(1.5, "cm")
    )+
    custom_theme
