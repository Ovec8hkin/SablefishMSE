rm(list=ls())

library(tidyverse)
library(ggdist)
library(ggh4x)
library(reshape2)
library(SpatialSablefishAssessment)
library(tictoc)
library(doParallel)

# library(afscOM) # may work but not certain

# Change to wherever your local copy of afscOM is
library(devtools)
afscOM_dir <- "~/Desktop/Projects/afscOM"
sablefishMSE_dir <- here::here()

devtools::load_all(afscOM_dir)
devtools::load_all(sablefishMSE_dir)

source("R/reference_points.R")
source("R/harvest_control_rules.R")
source("R/simulate_TAC.R")
source("R/age_structure_stats.R")
source("R/data_utils.R")
source("R/data_processing.R")
source("R/run_mse.R")
source("R/run_mse_multiple.R")
source("R/run_mse_parallel.R")
source("R/format_em_data.R")
source("R/fit_TMB_model.R")
source("R/recruitment_utils.R")
source("R/setup_mse_options.R")

#' 1. Set up the OM by defining demographic parameters
#' model options (such as options governing the observation
#' processes), and OM initial conditons
nyears <- 100

sable_om <- readRDS("data/sablefish_om_big.RDS") # Read this saved OM from a file

sable_om$model_options$obs_pars <- list(
    # longline fishery, trawl fishery, longline survey, trawl survey
    is_survey   = c(0, 0, 1, 1),  # is this a survey (1) or fishery (0)
    qs          = c(1, 1, 6.41, 0.85), # catchability coefficient (q) for surveys
    rpn         = c(0, 0, 1, 1), # should RPNs be computed (yes=1, no=0)
    rpn_cv      = c(0, 0, 0.1, 0.1), # RPN CV
    rpw         = c(0, 0, 1, 1), # should RPWs be computed (yes=1, no=0)
    rpw_cv      = c(0, 0, 0.1, 0.1), # RPW CV
    acs         = c(1, 1, 1, 1), # should age compositions be computed (yes=1, no=0)
    ac_samps    = c(50, 30, 50, 30), # total sample size for age composition observations
    ac_as_integers  = c(TRUE, TRUE, TRUE, TRUE), # return age comps as integers (TRUE) or proportions (FALSE)
    acs_agg_sex     = c(FALSE, FALSE, FALSE, FALSE) # should age comps be aggregated by sex
)

# sable_om$model_options$fleet_apportionment <- matrix(c(sable_om$model_options$fleet_apportionment[[1]], sable_om$model_options$fleet_apportionment[[2]]), ncol=2)

# Define recruitment to occur via historical resampling
assessment <- dget("data/sablefish_assessment_2023.rdat")
hist_recruits <- assessment$natage.female[,1]*2

# sable_om$recruitment$func <- beverton_holt
# sable_om$recruitment$pars <- list(
#     h = 0.7,
#     R0 = 20,
#     S0 = 282,
#     sigR = 1.04
# )

# sable_om$recruitment$func <- resample_regime_recruits
# sable_om$recruitment$pars <- list(
#     regime1_recruits = hist_recruits[-c(20:24, 40:44, 57:63)],
#     regime2_recruits = hist_recruits[c(20:24, 40:44, 57:63)],
#     nyears = nyears - length(hist_recruits) + 1,
#     regime_length = c(20, 5),
#     starting_regime = 0
# )

sable_om$recruitment$func <- resample_recruits
sable_om$recruitment$pars <- list(
    hist_recruits = hist_recruits,
    nyears = nyears - length(hist_recruits) + 1
)

# sable_om$recruitment$func <- regime_recruits
# sable_om$recruitment$pars <- list(
#     mus = c(25, 10),
#     cvs = c(0.40, 0.40),
#     nyears = nyears - length(hist_recruits) + 1,
#     regime_length = c(20, 20),
#     starting_regime = 0
# )

#' 2. Define a harvest control rule (HCR) function to use to project TAC
#' in future years. Such function must take accept the following parameters:
#' ref_pts: a list of reference points as generated by `calculate_ref_points`,
#'          (Fref and Bref)
#' naa: a vector of numbers-at-age for a given year (should be [1, nages, nsexes, nregions])
#' dem_params: a list of demographic parameter values subsetted to a single year
#' 
#' HCR functions can accept as many additional parameters as required.
#' 
#' Below is an example implementation of the NPFMCs Tier 3a HCR     
tier3 <- function(ref_pts, naa, dem_params){
    ssb <- apply(naa[,,1,]*dem_params$waa[,,1,,drop=FALSE]*dem_params$mat[,,1,,drop=FALSE], 1, sum)
    return(
        npfmc_tier3_F(ssb, ref_pts$Bref, ref_pts$Fref)
    )
}

# Going to start an MSE Options list distinct from everything else
mse_options <- setup_mse_options() # get default values
mse_options$management$tac_land_reduction = 0.80 # only ~80% of TAC is used annually

mp <- mse_options
mp$hcr <- list(
    func = tier3,
    extra_pars = NA,
    extra_options = list(
        max_stability = NA,
        harvest_cap = NA
    ),
    units = "F"
)



#' 3. Run the closed-loop MSE simulation
#' A single MSE simulation can be run using the `run_mse(...)`
#' function, while multiple MSE simulations can be run (serially)
#' using the `run_mse_multiple(...)` function.
#' 
#' It is recommended to always use `run_mse_multiple(...)` even
#' when only a single MSE simulation is required.
set.seed(1007)
nsims <- 9
seeds <- sample(1:(1000*nsims), nsims)  # Draw 10 random seeds

tic()
# mse_tier3     <- run_mse_parallel(nsims=nsims, seeds=seeds, nyears=150, om=sable_om, hcr=tier3)
mse_small_1 <- run_mse_parallel(
    nsims=nsims, 
    seeds=seeds, 
    nyears=nyears, 
    om=sable_om, 
    hcr=mp, 
    mse_options=mse_options
)

# hcr$extra_options$harvest_cap <- 20

# mse_small_2 <- run_mse_parallel(
#     nsims=nsims, 
#     seeds=seeds, 
#     nyears=nyears, 
#     om=sable_om, 
#     hcr=hcr, 
#     mse_options=mse_options
# )

toc()

# nsims <- 1
# seeds <- sample(1:(1000*nsims), nsims)  # Draw 10 random seeds
# ms_small <- run_mse_multiple(nsims=nsims, seeds=seeds, nyears=100, om=sable_om, hcr=tier3)

# Example of running a single MSE simulation
# mse_tier3     <- run_mse(om=sable_om, hcr=hcr, mse_options=mse_options, nyears_input=100)

#' 4. Process MSE results
#' An example processing routine to plot the OM spawning biomass,
#' aggregated over multiple simulations, alongside the EM estimate
#' of spawning biomass.
model_runs <- list(
    # mse_tier3
    mse_small_1
)
extra_columns <- list(
    hcr = c("No Harvest Cap")
    # hcr = c("No Harvest Cap", "12,000mt Harvest Cap")
)

ssb_data <- get_ssb_biomass(model_runs, extra_columns, sable_om$dem_params)
ssb_plot <- plot_ssb(ssb_data)
ssb_plot$layers[[2]] <- NULL
ssb_plot

# Plot fishing mortality rates from OM and EM
f_data <- get_fishing_mortalities(model_runs, extra_columns)
plot_fishing_mortalities(f_data)

r_data <- get_recruits(model_runs, extra_columns)
plot_recruitment(r_data)

abctac <- get_management_quantities(model_runs, extra_columns)
plot_abc_tac(abctac)

catch_data <- get_landed_catch(model_runs, extra_columns)
plot_landed_catch(catch_data)+scale_y_continuous(limits=c(0, 60))

# Phase plane diagrams
plot_phase_diagram(model_runs, extra_columns, sable_om$dem_params, nyears)
plot_hcr_phase_diagram(model_runs, extra_columns, sable_om$dem_params, nyears)
  
get_reference_points(model_runs, extra_columns, sable_om$dem_params, nyears)


bind_mse_outputs(model_runs, c("naa", "caa"), extra_columns) %>%
    as_tibble() %>%
    mutate(
        class = factor(
            case_when(age < 3 ~ "1/2", age < 5 ~ "2/3", age < 7 ~ "3/4", age < 9 ~ "4/5", age < 15 ~ "5/7", age > 14 ~ "7+"), 
            levels=c("1/2", "2/3", "3/4", "4/5", "5/7", "7+"), 
            labels=c("Grade 1/2 (1-2yo)", "Grade 2/3 (3-4yo)", "Grade 3/4 (5-6yo)", "Grade 4/5 (7-8yo)", "Grade 5/7 (9-14yo)", "Grade 7+ (15+yo)")
        ),
        L1 = factor(L1, levels=c("caa", "naa"), labels=c("Catch-at-Age", "Numbers-at-Age"))
    ) %>%
    group_by(time, class, sim, hcr, L1) %>%
    summarise(value=sum(value)) %>%
    group_by(time, class, hcr, L1) %>%
    median_qi(value, .width=c(0.50)) %>%

    ggplot()+
        geom_bar(aes(x=time, y=value, fill=class), position="fill", stat="identity")+
        geom_vline(xintercept = 2022-1960+1, color="white", size=1.25, linetype="dashed")+
        scale_fill_viridis(direction=-1, discrete=TRUE, option="magma")+
        scale_x_continuous(breaks=seq(1, nyears+1, 20), labels=seq(1960, 1960+nyears+1, 20))+
        coord_cartesian(expand=0)+
        labs(x="Year", fill="Age Group")+
        guides(fill=guide_legend(reverse=TRUE))+
        facet_wrap(~L1, ncol=1, scales="free_x")+
        theme_bw()+
        theme(
            axis.text = element_text(size=12),
            axis.title.y=element_blank(), 
            strip.background = element_blank(),
            strip.text.x = element_text(size=16, hjust=0),
            panel.spacing.y = unit(0.4, "in"),
            legend.position = "bottom"
        )
